{"version":3,"file":"apiz.umd.js","sources":["../../../src/core.ts","../../../src/querystring.ts","apiz.js"],"sourcesContent":["/* global DEBUG */\nimport { Omit } from 'type-fest';\n\nexport type HTTPMethodUpperCase = 'GET' | 'POST' | 'HEAD' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS';\n\nexport type HTTPMethodLowerCase = 'get' | 'post' | 'head' | 'put' | 'patch' | 'delete' | 'options';\n\ntype HTTPMethod = HTTPMethodUpperCase | HTTPMethodLowerCase;\n\ntype Callable = (...args: Array<any>) => any;\n\n// from https://stackoverflow.com/questions/50374908/transform-union-type-to-intersection-type\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\n\ninterface KVObject {\n\t[k: string]: any;\n}\n\nexport type Serialize2QueryString = (obj: any) => string;\n\ninterface APIMetaInfoWithURL<T extends string, M> {\n\turl: string;\n\tmethod?: HTTPMethod;\n\t// type应当由APIzClient提供, 这里暂定string\n\ttype?: T;\n\tpathParams?: boolean;\n\t// meta的类型也应当由APIzClient提供, 这里暂定any\n\tmeta?: M;\n}\n\ninterface APIMetaInfoWithPath<T extends string, M> {\n\tbaseURL?: string;\n\tpath: string;\n\tmethod?: HTTPMethod;\n\t// type应当由APIzClient提供, 这里暂定string\n\ttype?: T;\n\tpathParams?: boolean;\n\t// meta的类型也应当由APIzClient提供, 这里暂定any\n\tmeta?: M;\n}\n\nexport type APIMetaInfo<T extends string, M> = APIMetaInfoWithURL<T, M> | APIMetaInfoWithPath<T, M>;\n\ninterface APIMetaWithoutBaseURL<T extends string, M> {\n\t[key: string]: APIMetaInfo<T, M>;\n}\n\ninterface APIMetaWithBaseURL {\n\t_baseURL?: string;\n}\n\n// 为什么不把这两个放一个接口, 放一个接口的话, 索引类型还需要联合undefined和string\n// 然而对于APIMetaInfo, 是不允许undefined和string, 所以拆两个接口用&\nexport type APIMeta<T extends string, M> = APIMetaWithBaseURL & Omit<APIMetaWithoutBaseURL<T, M>, '_baseURL'>;\n\nexport interface ClientRequestOptions<T extends string, M, O> {\n\turl: string;\n\tname: string;\n\tmeta?: M;\n\toptions?: O;\n\ttype?: T;\n\tbody?: any;\n}\n\nexport type APIzClient<T extends string, M, O, H extends HTTPMethodLowerCase> = {\n\t[K in H]?: (options: ClientRequestOptions<T, M, O>) => Promise<any>;\n}\n\nexport interface GlobalOptions<T extends string, M, O, C extends APIzClient<T, M, O, HTTPMethodLowerCase>> {\n\tclient?: C;\n\tparamRegex?: RegExp;\n\tdefaultType?: string;\n\timmutableMeta?: boolean;\n\treset?: boolean;\n\tquerystring?(obj: object): string;\n}\n\nexport interface APIzOptions<C> {\n\tbaseURL?: string;\n\tclient?: C;\n\timmutableMeta?: boolean;\n\tparamRegex?: RegExp;\n\tquerystring?: Serialize2QueryString;\n}\n\ninterface ParsedAPIMetaInfo<T extends string, M, O> extends APIzClient<T, M, O, HTTPMethodLowerCase> {\n\turl: string;\n\tbaseURL: string;\n\tpath: string;\n\tname: string;\n\tmeta?: M;\n\tmethod: HTTPMethodUpperCase;\n\tmethodLowerCase: HTTPMethodLowerCase;\n\ttype: T;\n\tpathParams: boolean;\n\tregex: RegExp;\n\tquerystring: Serialize2QueryString;\n\tinit: boolean;\n};\n\nexport interface APIzRequest<T, M, O> {\n\t// with body\n\t(body: any, params: KVObject, query: KVObject | string, type: T): Promise<any>;\n\t(body?: any, params?: KVObject, query?: KVObject | string): Promise<any>;\n\t(body: any, params: KVObject | string, type: T): Promise<any>;\n\t// (body: any, params: KVObject): Promise<any>;\n\t// (body: any, query: KVObject | string, type: T): Promise<any>;\n\t(body: any, query: KVObject | string): Promise<any>;\n\t(body: any, type: T): Promise<any>;\n\t// (body: any): Promise<any>;\n\t// without body\n\t(params: KVObject, query?: KVObject | string): Promise<any>;\n\t// (params: KVObject): Promise<any>;\n\t(query: KVObject | string): Promise<any>;\n\t// (): Promise<any>;\n\t(clientOptions: O, optionsFlag: boolean): Promise<any>;\n\treadonly url: string;\n\treadonly method: HTTPMethodUpperCase;\n\treadonly meta: M;\n\treadonly type: T;\n\treadonly pathParams: boolean;\n}\n\n\ntype ProxyMeta<T extends string, M, O, N extends APIMeta<T, M>> = {\n\t[K in keyof N]: APIzRequest<T, M, O>;\n}\n\ninterface APIzMethod<T extends string, M> {\n\tadd: (name: string, apiInfo: APIMetaInfo<T, M>) => this;\n\tremove: (name: string) => this;\n}\n\nexport type APIzInstance<T extends string, M, O, N extends APIMeta<T, M>> =  APIzMethod<T, M> & Omit<ProxyMeta<T, M, O, N>, 'add' | 'remove'>;\n\n\nconst toString = (Map as unknown as () => any).call.bind(Object.prototype.toString);\nconst isObj = (o: any) => toString(o) === '[object Object]';\nconst isFn = (f: any): f is Callable => typeof f === 'function';\nconst isStr = (s: any): s is string => s && typeof s === 'string';\nconst isEnumerable = (Map as unknown as () => any).call.bind(Object.prototype.propertyIsEnumerable);\n\nlet defaultType: string | undefined,\n\tglobalQuerystring: Serialize2QueryString | undefined,\n\tglobalParamRegex: RegExp | undefined,\n\t// 这东西有没有, 是什么类型, 应该只能在运行时才能确定了, 或者分析控制流?\n\t// 那就随便写个类型吧...等到使用处as一下好了\n\tglobalClient: APIzClient<any, any, any, HTTPMethodLowerCase> | undefined,\n\tglobalImmutableMeta: boolean | undefined = false;\n\n// ES2018+, 是讲这个特性没法被babel转译,\n// 那既然都用ES2018了, 不如把能用的特性都用上好了...\nconst defaultParamRegex = /:((\\w|-)+)/g,\n\tslashRegex = /\\/\\//g,\n\tmethodMap = {\n\t\tget: noBodyRequest,\n\t\thead: noBodyRequest,\n\t\tpost: bodyRequest,\n\t\tput: bodyRequest,\n\t\tpatch: bodyRequest,\n\t\t// 尽管浏览器支持OPTIONS和DELETE带body, 但是考虑到不常用,\n\t\t// 还是默认它们不带body, 如果需要的话, 可以直接开启完整选项加入body\n\t\t// 有空改成可配置吧\n\t\toptions: noBodyRequest,\n\t\tdelete: noBodyRequest\n\t},\n\treplaceSlash = (m: string, o: number) => o <= 6 ? m : '/';\n\n\nfunction parseApiInfo<T extends string, M, O, C extends APIzClient<T, M, O, HTTPMethodLowerCase>>(\n\tname: string,\n\trawInfo: UnionToIntersection<APIMetaInfo<T, M>>,\n\t{ baseURL: gBaseURL, paramRegex, querystring, client }: {\n\t\tbaseURL?: string;\n\t\tparamRegex: RegExp;\n\t\tquerystring: Serialize2QueryString;\n\t\tclient: C\n\t}\n): ParsedAPIMetaInfo<T, M, O> | never {\n\t// tslint:disable-next-line\n\tlet { url, baseURL, path, meta, method = 'GET' as HTTPMethodUpperCase, type = defaultType as T, pathParams = false } = rawInfo;\n\tconst info = {} as ParsedAPIMetaInfo<T, M, O>,\n\t\tbURL = baseURL || gBaseURL;\n\n\tif (name === 'remove' || name === 'add') {\n\t\tthrow new Error('\"remove\" and \"add\" is preserved key.');\n\t}\n\tif (!isObj(rawInfo)) {\n\t\tthrow new TypeError(`API ${name} expected an object, but received ${JSON.stringify(rawInfo)}.`);\n\t}\n\tif (isStr(url)) {\n\t\tinfo.url = url;\n\t} else if (isStr(bURL)) {\n\t\tinfo.url = (bURL + (path || '')).replace(slashRegex, replaceSlash);\n\t} else {\n\t\tthrow new Error(`API \"${name}\" must set url or baseURL correctly.`);\n\t}\n\tmethod = method.toUpperCase() as HTTPMethodUpperCase;\n\tconst methodLowerCase = method.toLowerCase() as HTTPMethodLowerCase;\n\tif (!['GET', 'HEAD', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'].includes(method)) {\n\t\tthrow new Error(`Unsupported HTTP method: ${method}.`);\n\t}\n\tif (!isFn((client as any)[methodLowerCase])) {\n\t\tthrow new Error(`client must implement a ${methodLowerCase} function.`);\n\t}\n\tconst parts = info.url.split(/\\/(?=\\w|:)/g), offset = /^(https?:|\\/)/.test(parts[0]) ? 2 : 1;\n\tinfo.baseURL = parts.slice(0, offset).join('/');\n\tinfo.path = `/${parts.slice(offset).join('/')}`;\n\tinfo.name = name;\n\tinfo.meta = meta;\n\tinfo.method = method;\n\tinfo.methodLowerCase = methodLowerCase;\n\tinfo[methodLowerCase] = client[methodLowerCase];\n\tinfo.type = type;\n\tinfo.pathParams = pathParams;\n\tinfo.regex = paramRegex;\n\tinfo.querystring = querystring;\n\tinfo.init = true;\n\treturn info;\n}\n\nfunction replaceParams(params: KVObject): (m: string, v: string) => string | never {\n\treturn (m: string, v: string) => {\n\t\tif (params[v] == null) {\n\t\t\tthrow new Error(`Can't find a property \"${v}\" in params.`);\n\t\t}\n\t\treturn encodeURIComponent(params[v]);\n\t};\n}\n\n\n// 其实noBodyRequest和bodyRequest我们可以合并成一个,\n// 因为我们已经知道method了, 也就可以知道它是否会带body,\n// 但是考虑到让代码更加清晰一点, 还是拆成两个吧, 这点\n// 代码重复算是可以接受. 另一方面讲, 其实也可以让接口只\n// 实现一个request方法就好, 而不用对每个HTTP方法都实现一个\n// 对应的方法, 因为我们也可以把method传过去\nfunction noBodyRequest<T extends string, M, O>(this: ParsedAPIMetaInfo<T, M, O>, ...args: Array<any>): Promise<any> | never {\n\tconst { methodLowerCase, pathParams, regex, querystring, baseURL, path } = this;\n\tlet params, query, qs, url = this.url;\n\tif (args[1] === true) {\n\t\t// 接口处记得检测对象是否为空\n\t\treturn this[methodLowerCase]!({\n\t\t\turl,\n\t\t\tname: this.name,\n\t\t\tmeta: this.meta,\n\t\t\toptions: args[0]\n\t\t});\n\t} else if (pathParams) {\n\t\tparams = args[0];\n\t\tquery = args[1];\n\t} else {\n\t\tquery = args[0];\n\t}\n\n\tif (params) {\n\t\turl = baseURL + path.replace(regex, replaceParams(params));\n\t} else if (pathParams) {\n\t\tthrow new Error('Path params is required.');\n\t}\n\n\tif (query) {\n\t\tqs = querystring(query);\n\t\turl = url.includes('?') ? `${url}&${qs}` : `${url}?${qs}`;\n\t}\n\treturn this[methodLowerCase]!({\n\t\turl,\n\t\tname: this.name,\n\t\tmeta: this.meta\n\t});\n}\n\nfunction bodyRequest<T extends string, M, O>(this: ParsedAPIMetaInfo<T, M, O>, ...args: Array<any>): Promise<any> | never {\n\t// $以区分全局变量\n\tconst { methodLowerCase, type: $defaultType, pathParams, regex, querystring, baseURL, path } = this;\n\tlet params, query, body, type, qs, url = this.url;\n\tif (args[1] === true) {\n\t\treturn this[methodLowerCase]!({\n\t\t\turl,\n\t\t\ttype,\n\t\t\tname: this.name,\n\t\t\tmeta: this.meta,\n\t\t\toptions: args[0]\n\t\t});\n\t} else if (pathParams) {\n\t\tparams = args[1];\n\t\tquery = args[2];\n\t\ttype = args[3] || $defaultType;\n\t} else {\n\t\tquery = args[1];\n\t\ttype = args[2] || $defaultType;\n\t}\n\tbody = args[0];\n\n\tif (params) {\n\t\turl = baseURL + path.replace(regex, replaceParams(params));\n\t} else if (pathParams) {\n\t\tthrow new Error('Path params is required.');\n\t}\n\n\t// 这里实际上会造成带body的query的集合和不带body的query的集合不一致,\n\t// 不过考虑实际情况这样的不一致也是可以接受\n\tif (isStr(query) && !query.includes('=')) {\n\t\ttype = query;\n\t} else if (query) {\n\t\tqs = querystring(query);\n\t\turl = url.includes('?') ? `${url}&${qs}` : `${url}?${qs}`;\n\t}\n\treturn this[methodLowerCase]!({\n\t\turl,\n\t\ttype,\n\t\tbody,\n\t\tname: this.name,\n\t\tmeta: this.meta\n\t});\n}\n\nfunction createAPI<T extends string, M, O>(info: ParsedAPIMetaInfo<T, M, O>): APIzRequest<T, M, O> | never {\n\t// const fn = methodMap[info.method]\n\tconst f = (methodMap as unknown as ParsedAPIMetaInfo<T, M, O>)[info.methodLowerCase];\n\tif (!f) {\n\t\tthrow new Error(`APIzClient must implement ${info.methodLowerCase} method.`);\n\t}\n\tconst fn = f.bind(info);\n\n\t['url', 'method', 'meta', 'type', 'pathParams'].forEach(k => {\n\t\tObject.defineProperty(fn, k, {\n\t\t\tvalue: (info as any)[k],\n\t\t\tenumerable: true,\n\t\t\twritable: false\n\t\t});\n\t});\n\treturn fn as APIzRequest<T, M, O>;\n}\n\n\n\n\n// 理想情况下是这样的\n// class APIz<T, M, N extends APIMeta<T, M>> {\n// \tpublic add: (name: string, apiInfo: APIMetaInfo<T, M>) => this;\n// \tpublic remove: (name: string) => this;\n// \t[K in key of N]: object;\n// \tconstructor(apiMeta: N, options: APIzOptions<>) {\n\t\t\n// \t}\n// }\n\n// type ProxyMeta<T, M, N extends APIMeta<T, M>> = {\n// \t[K in keyof N]: object;\n// };\n\n// TODO 这里有重载, params还是query由配置选项中的pathParams作为隐式参数决定了\n// type APIzRequestWithBody<T extends string> = ((body: any, params: KVObject, query: KVObject | string, type: T) => Promise<any>)\n// \t| ((body: any, params: KVObject, query: KVObject | string) => Promise<any>)\n// \t| ((body: any, params: KVObject, type: T) => Promise<any>)\n// \t| ((body: any, params: KVObject) => Promise<any>)\n// \t| ((body: any, query: KVObject | string, type: T) => Promise<any>)\n// \t| ((body: any, query: KVObject | string) => Promise<any>)\n// \t| ((body: any, type: T) => Promise<any>)\n// \t| ((body: any) => Promise<any>);\n\n// // TODO 这里有重载, params还是query由配置选项中的pathParams作为隐式参数决定了\n// type APIzRequestWithoutBody = ((params: KVObject, query: KVObject | string) => Promise<any>)\n// \t| ((params: KVObject) => Promise<any>)\n// \t| ((query: KVObject | string) => Promise<any>)\n// \t| (() => Promise<any>);\n\n\n\n\n\n// type APIzConstructor<C, T extends string, M, N extends APIMeta<T, M>> =\tnew (apiMeta: N, options: APIzOptions<C>) => APIzInstance<T, M, N>;\n// class不知道怎么实现mapped types, 用function又没办法直接\n// 实现上面的constructor接口, 只能是让ts中不允许new调用, js中运行new调用了\n// 其实也没什么影响, 除了看上去不那么面向对象少个new\n// 另外泛型参数过多有什么好的解决办法?\nfunction APIz<T extends string, M, O, C extends APIzClient<T, M, O, HTTPMethodLowerCase>, N extends APIMeta<T, M>>(apiMeta: N, options?: APIzOptions<C>): APIzInstance<T, M, O, N> | never {\n\tlet baseURL: string | undefined,\n\t\timmutableMeta: boolean,\n\t\tparamRegex: RegExp,\n\t\tquerystring: Serialize2QueryString,\n\t\tclient: C,\n\t\tmeta = {} as APIMeta<T, M>;\n\n\tisStr(apiMeta._baseURL) && (baseURL = apiMeta._baseURL);\n\n\t({\n\t\tbaseURL = baseURL,\n\t\t// 这里undefined没什么影响, 视为boolean没问题\n\t\timmutableMeta = globalImmutableMeta as boolean,\n\t\tparamRegex = globalParamRegex || defaultParamRegex,\n\t\t// 这里querystring虽然可能为undefined, 但是后面立马检测了是否为callable,\n\t\t// 为了给js用户提示, 所以这里也可以暂时视为不为undefined\n\t\tquerystring = globalQuerystring as Serialize2QueryString,\n\t\tclient = globalClient as C\n\t} = options || {});\n\n\tif (!isFn(querystring)) {\n\t\tthrow new Error('A querystring function must set.');\n\t}\n\n\tif (!client) {\n\t\tthrow new Error('A client must set.');\n\t}\n\n\tconst groupOptions = {\n\t\tbaseURL,\n\t\tparamRegex,\n\t\tquerystring,\n\t\tclient\n\t};\n\n\tif (immutableMeta) {\n\t\tmeta = apiMeta || {};\n\t} else {\n\t\t// 不用Object.keys, 允许配置对象继承\n\t\tfor (const key in apiMeta) {\n\t\t\tif (isObj(apiMeta[key])) {\n\t\t\t\tmeta[key] = parseApiInfo<T, M, O, C>(key, apiMeta[key as keyof APIMeta<T, M>] as UnionToIntersection<APIMetaInfo<T, M>>, groupOptions);\n\t\t\t} else if (key !== '_baseURL') {\n\t\t\t\tconsole.warn(`The ${key} in meta is not an object.`);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst pxy = new Proxy({}, {\n\t\tget(target, key, receiver) {\n\t\t\tif (!meta[key as string] || !isEnumerable(meta, key)) {\n\t\t\t\treturn Reflect.get(target, key);\n\t\t\t} else if (!(meta[key as string] as ParsedAPIMetaInfo<T, M, O>).init) {\n\t\t\t\tmeta[key as string] = parseApiInfo<T, M, O, C>(key as string, meta[key as string] as UnionToIntersection<APIMetaInfo<T, M>>, groupOptions);\n\t\t\t}\n\t\t\t// 到这里有个meta[key]在运行时从APIMetaInfo到ParsedAPIMetaInfo的类型转换\n\t\t\t// 只能是强行as了\n\t\t\tconst apiFn = createAPI(meta[key as string] as ParsedAPIMetaInfo<T, M, O>);\n\t\t\tReflect.set(receiver, key, apiFn);\n\t\t\treturn apiFn;\n\t\t},\n\t\tgetPrototypeOf() {\n\t\t\treturn APIz.prototype;\n\t\t}\n\t});\n\n\tconst self = Object.create(pxy) as APIzInstance<T, M, O, N>;\n\tself.remove = function (name: string): APIzInstance<T, M, O, N> {\n\t\tthis[name] && ((meta[name] as any) = (this[name] as any) = undefined);\n\t\treturn this;\n\t};\n\tself.add = function (name: string, apiInfo: APIMetaInfo<T, M>): APIzInstance<T, M, O, N> {\n\t\tif (meta[name]) {\n\t\t\tthrow new Error(`API \"${name}\" already exists.`);\n\t\t}\n\t\tmeta[name] = parseApiInfo<T, M, O, C>(name, apiInfo as UnionToIntersection<APIMetaInfo<T, M>>, groupOptions);\n\t\t// 同前面一样存在运行时类型转换\n\t\tthis[name] = createAPI(meta[name] as ParsedAPIMetaInfo<T, M, O>);\n\t\treturn this;\n\t};\n\treturn self;\n}\n\nexport { APIz };\n\nexport function config<T extends string, M, O, C extends APIzClient<T, M, O, HTTPMethodLowerCase>>(\n\t{\n\t\tquerystring, paramRegex, immutableMeta, client, reset, defaultType: dt\n\t}: GlobalOptions<T, M, O, C> = { reset: true }\n\t) {\n\tisFn(querystring) && (globalQuerystring = querystring);\n\tparamRegex instanceof RegExp && (globalParamRegex = paramRegex);\n\tglobalImmutableMeta = immutableMeta;\n\tglobalClient = client;\n\tdefaultType = dt;\n\treset && (globalQuerystring = globalParamRegex = globalClient = defaultType = undefined, globalImmutableMeta = false);\n}\n","import { Serialize2QueryString } from './core';\n\nexport const querystring: Serialize2QueryString = function (obj) {\n\tif (Object.prototype.toString.call(obj) === '[object Object]') {\n\t\treturn Object.keys(obj)\n\t\t\t.map(\n\t\t\t\tk =>\n\t\t\t\t\tArray.isArray(obj[k])\n\t\t\t\t\t\t? obj[k]\n\t\t\t\t\t\t\t.map((v: any) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n\t\t\t\t\t\t\t.join('&')\n\t\t\t\t\t\t: `${encodeURIComponent(k)}=${encodeURIComponent(obj[k])}`\n\t\t\t)\n\t\t\t.join('&');\n\t} else if (typeof obj === 'string') {\n\t\treturn obj;\n\t} else {\n\t\treturn JSON.stringify(obj);\n\t}\n}","import { config } from './core';\nimport { querystring } from './querystring';\n\nconfig({\n\tquerystring,\n\tdefaultType: 'json'\n});\n\nexport * from './core';"],"names":[],"mappings":"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"}